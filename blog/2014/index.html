<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Blog: 2014 | Xiongmin Lin</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Hi, welcome to Xiongmin Lin&apos;s website">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiongmin Lin">
<meta property="og:url" content="http://linxiongmin.com/blog/2014/index.html">
<meta property="og:site_name" content="Xiongmin Lin">
<meta property="og:description" content="Hi, welcome to Xiongmin Lin&apos;s website">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xiongmin Lin">
<meta name="twitter:description" content="Hi, welcome to Xiongmin Lin&apos;s website">

  
    <link rel="alternate" href="/atom.xml" title="Xiongmin Lin" type="application/atom+xml">
  

  
  <!--[if lte IE 10 ]><link rel="shortcut icon" href="/images/favicon.ico"><![endif]-->
  <!--[if !IE]><!-->
  <link rel="shortcut icon" href="/images/favicon.png">

  <meta name="msapplication-TileImage" content="/images/favicon.png">
  <meta name="msapplication-TileColor" content="#000000">

  <link rel="apple-touch-icon" href="/images/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png">

  <link rel="icon" sizes="256x256" href="/images/favicon.png">
  <!--<![endif]-->
  

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro|Material+Icons|Raleway:400,300,700" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="/css/vendors.css">
  <link rel="stylesheet" href="/css/style.css">
  


  <script src="/js/vendors.js"></script>

  <script>
    define('jquery', function () {
      return window.jQuery;
    });
  </script>


</head>
<body>

  <div class="navbar-fixed">
  <nav id="main-navbar" class="grey lighten-5 z-depth-0" role="navigation">
    <div class="nav-wrapper container">

      <a id="logo-container" href="/" class="brand-logo center-align">
        <span>Xiongmin Lin</span>
        <sub></sub>
      </a>

      <ul class="right hide-on-med-and-down">
        
          <li>
            <a class="main-nav-link" href="/">Home</a>
          </li>
        
          <li>
            <a class="main-nav-link" href="/blog">Blog</a>
          </li>
        
          <li>
            <a class="main-nav-link" href="https://www.linkedin.com/in/shelmylin">Linkedin</a>
          </li>
        
      </ul>

      <a href="#" data-activates="nav-mobile" class="button-collapse">
        <i class="material-icons">menu</i>
      </a>
    </div>
  </nav>
</div>

<ul id="nav-mobile" class="side-nav">
  
  <li>
    <a class="main-nav-link" href="/">Home</a>
  </li>
  
  <li>
    <a class="main-nav-link" href="/blog">Blog</a>
  </li>
  
  <li>
    <a class="main-nav-link" href="https://www.linkedin.com/in/shelmylin">Linkedin</a>
  </li>
  
</ul>


  <div id="main-container">
    <div class="container">
  <div class="row">
    <div class="col s12">

      

      
        

      <article id="post-break_vigenere" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/12/30/break_vigenere/">Implementation and cryptanalysis of Vigenère</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-12-30T08:00:00.000Z" itemprop="datePublished">Dec 30, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="Implementation-of-Vigenere-cipher"><a href="#Implementation-of-Vigenere-cipher" class="headerlink" title="Implementation of Vigenère cipher"></a>Implementation of Vigenère cipher</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The Vigenère cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword.</p>
<h2 id="Lab-exercise"><a href="#Lab-exercise" class="headerlink" title="Lab exercise"></a>Lab exercise</h2><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>Implement a program that asks the user for a text, and that displays it. Modify your program so that all letters are converted to lower-case, and all non-letter characters are removed.</p>
<h3 id="Main-idea"><a href="#Main-idea" class="headerlink" title="Main idea"></a>Main idea</h3><p>Getting the input text and keyword. We don’t know the length of input text and keyword, so we just use malloc and realloc function to allocate address space for input text and keyword.  If they are capital letter, change them to the lower-case. After that, removing the non-letter characters.</p>
<h3 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h3><h4 id="Input-text"><a href="#Input-text" class="headerlink" title="Input text"></a>Input text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Getting the input text and covert it using covert function.                               */</span><br><span class="line">/* to get a viginer cipher, you should input the plaintext(the longer, the better)  */ </span><br><span class="line">origintext = (char*) malloc(1000); </span><br><span class="line">printf(&quot;please input origin text \n&quot;); </span><br><span class="line">for(i = 0; (*(origintext + i) = getchar()) != &apos;\n&apos;; i++) </span><br><span class="line">&#123; </span><br><span class="line">  if((i+1) % 1000 == 0) </span><br><span class="line">  &#123; </span><br><span class="line">    origintext = (char*)realloc(origintext, strlen(origintext) + 1000); </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br><span class="line">origintext[i] = &apos;\0&apos;; </span><br><span class="line">plaintext = (char*)malloc(strlen(origintext));   </span><br><span class="line">memset(plaintext, &apos;\0&apos;, strlen(plaintext)); </span><br><span class="line">convert(origintext, plaintext);</span><br></pre></td></tr></table></figure>
<h4 id="Covert-the-text"><a href="#Covert-the-text" class="headerlink" title="Covert the text"></a>Covert the text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* convert function is used to covert the original text to  plaintext, delete  * </span><br><span class="line"> * no-letter char and covert captical letter to lowercase                               */ </span><br><span class="line">void convert(char *origintext, char *plaintext) </span><br><span class="line">&#123; </span><br><span class="line">  int i, j; </span><br><span class="line">  i = 0; </span><br><span class="line">  j = 0; </span><br><span class="line">  memset(plaintext, &apos;\0&apos;, strlen(plaintext)); </span><br><span class="line">  while(origintext[i] != &apos;\0&apos;) </span><br><span class="line">  &#123; </span><br><span class="line">    if(origintext[i] &lt;= &apos;Z&apos; &amp;&amp; origintext[i] &gt;= &apos;A&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[j] = origintext[i] + 32; </span><br><span class="line">      j++; </span><br><span class="line">    &#125; </span><br><span class="line">    if(origintext[i] &lt;= &apos;z&apos; &amp;&amp; origintext[i] &gt;= &apos;a&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[j] = origintext[i]; </span><br><span class="line">      j++; </span><br><span class="line">    &#125; </span><br><span class="line">    i++; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Input-the-key-word"><a href="#Input-the-key-word" class="headerlink" title="Input the key word"></a>Input the key word</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> /*input the key word*/ </span><br><span class="line">printf(&quot;please input the key\n&quot;); </span><br><span class="line">for(i = 0,key = (char*)malloc(100); (*(key + i) = getchar()) != &apos;\n&apos;; i++) </span><br><span class="line">&#123; </span><br><span class="line">  if((i + 1) % 100 == 0) </span><br><span class="line">  &#123; </span><br><span class="line">    key=(char*)realloc(key,strlen(key)+100); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">*(key+i)=&apos;\0&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>The result was shown in figure 1.1. The plain text was about the introduction of viginere, which came from wikipedia-viginere. The keyword was set to isima.<br><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93j220hcj20zq09i4b3.jpg" alt="figure 1.1"></p>
<center><em> Figure 1.1 encryption of plain text</em> </center>

<h1 id="Cryptanalysis-key-length-estimation"><a href="#Cryptanalysis-key-length-estimation" class="headerlink" title="Cryptanalysis: key length estimation"></a>Cryptanalysis: key length estimation</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>When the key length is known, a Vigenère cipher can be broken using frequency analysis. The primary weakness of the Vigenère cipher is the repeating nature of its key. If a cryptanalyst correctly guesses the key’s length, then the cipher text can be treated as interwoven Caesar ciphers, which individually are easily broken. The Kasiski and Friedman tests can help determine the key length.</p>
<h2 id="Babbage-and-Kasiki-method"><a href="#Babbage-and-Kasiki-method" class="headerlink" title="Babbage and Kasiki method"></a>Babbage and Kasiki method</h2><p>Friedrich Kasiski was the first to publish a successful general attack on the Vigenère cipher. Charles Babbage was goaded into breaking the Vigenère cipher when John Hall Brock Thwaites submitted a “new” cipher to the Journal of the Society of the Arts. When Babbage showed that Thwaites’ cipher was essentially just another recreation of the Vigenère cipher, Thwaites challenged Babbage to break his cipher encoded twice, with keys of different length.</p>
<h2 id="Lab-work"><a href="#Lab-work" class="headerlink" title="Lab work"></a>Lab work</h2><p>  To calculate the length of key work. I removed the letters whose repetitions were less than 2 times, and then get the distance between two same strings. After that I get divisors of each distance and calculate the weight of each divisor. With highest weight, we get the most probable probable length of key word.</p>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">/* get_key_size function is used to calculate the keysize of the key                                                               */ </span><br><span class="line">/* to avoid noise, get_key_size() calculates the weight of each possible keys and the result is                      */ </span><br><span class="line">/* more precise than previous get_key_size(), which just calculates the same divisor of all possible keys    */ </span><br><span class="line">/* input:  cipher text.                                                                                                                                         */</span><br><span class="line">/* output: the most probable length of key word.                                                                                             */</span><br><span class="line">/* Same_Str struct is used to stored the information of the same strings in ciphertext */ </span><br><span class="line">struct Same_Str&#123; </span><br><span class="line">  char str[1000]; </span><br><span class="line">  int  num;             // the repetition time of each string</span><br><span class="line">  int  start[1000];   //the start position of string</span><br><span class="line">  int  end[1000];    // the end position of string, distance = end[i] – start[i], i stands for each repetition. </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int get_key_size(char* ciphertext) </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  /* step 1: initialize work*/</span><br><span class="line"></span><br><span class="line">  int size = 0; </span><br><span class="line">  int i, j, m, k, r; </span><br><span class="line">  int len = strlen(ciphertext); </span><br><span class="line">  int *keysize = malloc(sizeof(int)*strlen(ciphertext)); </span><br><span class="line">  memset(keysize, 0, sizeof(int)*strlen(ciphertext));    // if possible key size is 27, set keysize[26]=1; </span><br><span class="line">  int malloc_size = 1000; </span><br><span class="line">  struct Same_Str *same_str = malloc(sizeof(struct Same_Str) * malloc_size); </span><br><span class="line">  int str_num; </span><br><span class="line">  str_num = 0; </span><br><span class="line">  for(i = 0; i &lt; malloc_size; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    same_str[i].num = 0; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  char *block_1 = malloc(len); </span><br><span class="line">  char *block_2 = malloc(len); </span><br><span class="line"></span><br><span class="line">/* step 2: compare each string, find the same string and store the information into Same_Str struct*/</span><br><span class="line"></span><br><span class="line">  for(m = 2; m &lt; len/2 ; m++)  //m -&gt; the length of blocks to be compared </span><br><span class="line">  &#123; </span><br><span class="line">    int block_num = len -m; </span><br><span class="line">    for(i = 0; i &lt; block_num; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      memset(block_1, &apos;\0&apos;, strlen(block_1)); </span><br><span class="line">      memcpy(block_1, ciphertext + i, m+1); </span><br><span class="line">      int w = 0;                                           </span><br><span class="line">      for(j = i + 1 + m; j &lt; block_num; j++) </span><br><span class="line">      &#123; </span><br><span class="line">        if(j &gt;= block_num) break; </span><br><span class="line">        memset(block_2, &apos;\0&apos;, strlen(block_2)); </span><br><span class="line">        memcpy(block_2, ciphertext + j, m+1); </span><br><span class="line">        if(strcmp(block_1, block_2) == 0) </span><br><span class="line">        &#123; </span><br><span class="line">           w++; </span><br><span class="line">    </span><br><span class="line">           int pos = same_str[str_num].num; </span><br><span class="line">           same_str[str_num].start[pos] = i; </span><br><span class="line">           same_str[str_num].end[pos]   = j; </span><br><span class="line">           same_str[str_num].num++;           </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      if(w &gt; 0) </span><br><span class="line">      &#123; </span><br><span class="line">        sprintf(same_str[str_num].str, &quot;%s&quot;, block_1); </span><br><span class="line">        printf(&quot;No.%d, found same block: %s, %d times\n&quot;,str_num, same_str[str_num].str, same_str[str_num].num); </span><br><span class="line">        str_num++; </span><br><span class="line">        if(str_num &gt;= malloc_size) </span><br><span class="line">        &#123; </span><br><span class="line">          malloc_size += 1000; </span><br><span class="line">          same_str = realloc(same_str, sizeof(struct Same_Str) * malloc_size); </span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">      &#125; </span><br><span class="line">      //usleep(100); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  free(block_1); </span><br><span class="line">  free(block_2); </span><br><span class="line"></span><br><span class="line">  /* step 3: removed the letters whose repetitions were less than 2 times */</span><br><span class="line"></span><br><span class="line">  /* from code above, we know all possible key sizes (count: str_num), which are stored in same_str array */ </span><br><span class="line">  /*if some strs whose replication time is more than 2, then it must be the REAL str*/ </span><br><span class="line">  k = 0; </span><br><span class="line">  for(m = 0; m &lt; str_num; m++ ) </span><br><span class="line">  &#123; </span><br><span class="line">    if(same_str[m].num &gt;= 2)  // just skip weak string, one replication string </span><br><span class="line">    &#123; </span><br><span class="line">      /*the REAL str*/ </span><br><span class="line">      for(r = 0; r &lt; same_str[m].num; r++) </span><br><span class="line">      &#123; </span><br><span class="line">        int start  = same_str[m].start[r]; </span><br><span class="line">        int end    = same_str[m].end[r]; </span><br><span class="line">      	keysize[k] = end - start; </span><br><span class="line">        k++;          </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 4: get the divisors of each distance and calculate their weight */</span><br><span class="line"></span><br><span class="line">  /* get max number of key size, to malloc the array, each possible key size will be split as an        * </span><br><span class="line">   * array ptr[i] and be added with an all-0 array: weight, from the weight of each key, we know     * </span><br><span class="line">   * the most possible keysize                                                                                                               */ </span><br><span class="line">  int **ptr = malloc(sizeof(int*)*k); </span><br><span class="line">  int max   = 0; </span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">     int num = keysize[i]; </span><br><span class="line">     max     = (max &gt; num)? max : num; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  int *weight = malloc(sizeof(int) * max); </span><br><span class="line">  for(i = 0; i &lt; max ;i++) </span><br><span class="line">  &#123; </span><br><span class="line">    weight[i] = 0; </span><br><span class="line">  &#125; </span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">     int num       = keysize[i]; </span><br><span class="line">     ptr[i]        = malloc(sizeof(int)*max); </span><br><span class="line">     ptr[i][num-1] = 1 ; </span><br><span class="line">     memset(ptr[i], 0, max); </span><br><span class="line"></span><br><span class="line">     /* at first, ptr[i] = &quot;00000...00100..&quot;, after get_divisor, ptr[i] = &quot;0..1..00..100..1..100...&quot;, * </span><br><span class="line">     * where 1 means the match pos is the divisor number of keysize[i]                               */ </span><br><span class="line">     get_divisor(ptr[i], num); </span><br><span class="line">     for(j = 0; j &lt; max; j++) </span><br><span class="line">     &#123; </span><br><span class="line">       weight[j] = weight[j] + ptr[i][j]; </span><br><span class="line">     &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 5, get the most probable length of key words through weight information*/</span><br><span class="line"></span><br><span class="line">  int max_weight = 0; </span><br><span class="line">  </span><br><span class="line">  for(j = 0; j &lt; max; j++) </span><br><span class="line">  &#123; </span><br><span class="line">    if(weight[j] != 0) </span><br><span class="line">    &#123; </span><br><span class="line">      printf(&quot;weight of %d: %d\n&quot;, j+1, weight[j]); </span><br><span class="line">    &#125; </span><br><span class="line">    if(max_weight &lt; weight[j]) </span><br><span class="line">    &#123; </span><br><span class="line">      size       = j+1; </span><br><span class="line">      max_weight = weight[j]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 6, free resources*/</span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    free(ptr[i]); </span><br><span class="line">  &#125;  </span><br><span class="line">  free(keysize); </span><br><span class="line">  free(weight); </span><br><span class="line">  free(ptr); </span><br><span class="line">  free(same_str); </span><br><span class="line">  return size; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><p>Figure 2.1 shows the same strings that were found. Figure 2.2 shows the weight of each probable key length. We can easily find the the number 5 has highest weight 226, and the key word that we input was “isima”, so we found the right length of key word, which was shown in figure 2.3.<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93jzcphij20pc07otcg.jpg" alt="Figure 2.1"></p>
<center><em>Figure 2.1  the same strings that werefound</em></center>

<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93lfzmdbj20sk06eab5.jpg" alt="Figure 2.2"></p>
<center><em>Figure 2.2  the weight of each probable key length</em></center>

<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93lx5asrj20so07w75u.jpg" alt="Figure 2.3"></p>
<center><em>Figure 2.3 most probable key length is 5</em> </center>

<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>If the length of key word was the number like 10 whose divisors were 1, 2, 5, 10. then the number 5 will have larger or at least equal weight as number 10. It’s a problem. I am sorry but I don’t know how to solve it.    </p>
<h1 id="Cryptanalysis-probable-word-method"><a href="#Cryptanalysis-probable-word-method" class="headerlink" title="Cryptanalysis: probable word method"></a>Cryptanalysis: probable word method</h1><h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><p>For most used English words, each character has a different frequency, which was shown in figure 3.1.<br><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq93mcsfp3j20rs04btas.jpg" alt="figure 3.1"></p>
<center><em>Figure 3.1 the frequency of each character in alphabet</em></center>

<h2 id="Lab-work-1"><a href="#Lab-work-1" class="headerlink" title="Lab work"></a>Lab work</h2><p>  To find the probable key word, we can detach the cipher into “key_length” part, for example, after calculation, the probable key length was 5, then we just detach the cipher into 5 parts, for the letters in each part, they have the same key character.<br>  After that, we choose 1 character from alphabet and try to decrypt each part of cipher text. Then, we compare frequency of the decryption text with the table of the most used English words, which was shown in figure 3.1. In this case, we just calculate the sample variance of the frequencies, the smaller sample variance, the better. Repeat the decryption of each characters in alphabet, we will get a minimum sample variance, then we get the most probable key character.<br>  Repeat “key length” time of the experiment, we will get the most probable key word.</p>
<h2 id="source-code-1"><a href="#source-code-1" class="headerlink" title="source code"></a>source code</h2><h3 id="Analyze-the-text-and-get-frequencies-of-each-character"><a href="#Analyze-the-text-and-get-frequencies-of-each-character" class="headerlink" title="Analyze the text and get frequencies of each character"></a>Analyze the text and get frequencies of each character</h3><p>For a given text, we can get the frequencies of each character and sample variance using anal_freq function. We can also get the probability that two randomly chosen letters are the same, which was named Ke. One of the result was shown in figure 3.2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/* anal_freq function is used to analyze the text, </span><br><span class="line">   input: </span><br><span class="line">   1. text to analyze </span><br><span class="line">   output: </span><br><span class="line">   1. the frequency of each 26 letters -&gt;m_fre[26] </span><br><span class="line">   2. The probability that two randomly chosen letters are the same -&gt; Ke </span><br><span class="line">   3. return value: the variance, to estimate the quality of decryption test. */ </span><br><span class="line"></span><br><span class="line">double anal_freq(char *text, double m_fre[26], double *Ke) </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  int i, pos; </span><br><span class="line">  int count; </span><br><span class="line"></span><br><span class="line">  /* the normal frequency for each 26 letters */ </span><br><span class="line">  double fre[26] = &#123;0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, </span><br><span class="line">                               0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749, </span><br><span class="line">                               0.07507, 0.01929, 0.00095,                0.05987, 0.06327, 0.09056, </span><br><span class="line">                               0.02758, 0.00978, 0.02360,                0.00150, 0.01974, 0.00074, &#125;; </span><br><span class="line"></span><br><span class="line">  /* the offset was set to verify that, no matter how    * </span><br><span class="line">   * you pick up a letter in an offset interval, the     * </span><br><span class="line">   * Ke results are always approximately equals to 0.067 */ </span><br><span class="line"></span><br><span class="line">  int offset      = 1; </span><br><span class="line">  double variance = 0; // to estimate the quality of decryption text </span><br><span class="line">  count = strlen(text); </span><br><span class="line"></span><br><span class="line">  /*get frequency of each letter; get Ke*/ </span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    m_fre[i] = 0; </span><br><span class="line">  &#125; </span><br><span class="line">  i = 0; </span><br><span class="line">  while(text[i] != &apos;\0&apos; &amp;&amp; i &lt; strlen(text)) </span><br><span class="line">  &#123; </span><br><span class="line">    pos = (int)(text[i] - &apos;a&apos;); </span><br><span class="line">    m_fre[pos]++; </span><br><span class="line">    i = i + offset; </span><br><span class="line">  &#125; </span><br><span class="line">  *Ke = 0; </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">   *Ke += (m_fre[i] * (m_fre[i] - 1)); </span><br><span class="line">  &#125; </span><br><span class="line">  count = count / offset; </span><br><span class="line"></span><br><span class="line">  *Ke = *Ke / (double)(count * (count - 1)); </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    m_fre[i] = m_fre[i] / (double)count; </span><br><span class="line">  &#125; </span><br><span class="line">  //printf(&quot;The probability that two randomly chosen letters are the same: %2.4f\n&quot;,Ke); </span><br><span class="line"></span><br><span class="line">  /*calculate the variance*/  </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    variance += pow((m_fre[i] - fre[i]), 2); </span><br><span class="line">  &#125;  </span><br><span class="line">  variance = variance / (double)25; </span><br><span class="line">  return variance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93mz7ofcj20ju0cwaer.jpg" alt="figure 3.2"></p>
<center><em>Figure 3.2 analyze the text</em></center>

<h3 id="Find-most-probable-key-character"><a href="#Find-most-probable-key-character" class="headerlink" title="Find most probable key character"></a>Find most probable key character</h3><p>  Repeat the decryption of each characters in alphabet, we will get a minimum sample variance, then we get the most probable key character. The result was shown in figure 3.3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*the find_each_key_letter function is used to find a most probable key letter for a given ciphertext*/ </span><br><span class="line">/* if the probable key size is 5, then the find_each_key_letter function will be execute for 5 time     */ </span><br><span class="line">/* input: seperated cipher text, for example, if peobable size is 5, then, the original ciphertext will   */ </span><br><span class="line">/*        be seperated into 5 parts, for all the letters in each part, their key letter are the same              */ </span><br><span class="line">/* output: the most probable letter, which has the minimum variance                                                 */ </span><br><span class="line"></span><br><span class="line">char find_each_key_letter(char *cipher) </span><br><span class="line">&#123; </span><br><span class="line">  int i; </span><br><span class="line">  double variance[26]; </span><br><span class="line">  double Ke[26]; </span><br><span class="line">  char key; </span><br><span class="line">  double Std_Ke = 0.067; </span><br><span class="line">  double min = 10000; // set a very big value, to find a min </span><br><span class="line">  double min_Ke_off = 1; </span><br><span class="line">  char *plaintext = malloc(strlen(cipher) + 1); </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    char prob_key[2]; </span><br><span class="line">    prob_key[0] = (char)(i + (int)(&apos;a&apos;)); </span><br><span class="line">    prob_key[1] = &apos;\0&apos;; </span><br><span class="line">    double freq[26]; </span><br><span class="line">    decrypt(cipher, prob_key, plaintext); </span><br><span class="line">    variance[i] = anal_freq(plaintext, freq, &amp;Ke[i]); </span><br><span class="line">    printf(&quot;probable key letter : %s, Ke = %f, variance = %f \n&quot;,prob_key,  Ke[i], variance[i]); </span><br><span class="line">    /*method 1: find the smallest variance*/ </span><br><span class="line">    if(variance[i]&lt; min ) </span><br><span class="line">    &#123; </span><br><span class="line">      key = prob_key[0]; </span><br><span class="line">      min = variance[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    /*method 2: find the closest Ke, this is wrong, because all the Ke are the same*/ </span><br><span class="line">    /*double off = (Ke[i] - Std_Ke) &gt; 0 ? (Ke[i] - Std_Ke) : (Std_Ke - Ke[i]); </span><br><span class="line">    if(off &lt; min_Ke_off) </span><br><span class="line">    &#123; </span><br><span class="line">      key = prob_key[0]; </span><br><span class="line">      min_Ke_off = off; </span><br><span class="line">    &#125;*/ </span><br><span class="line">  &#125; </span><br><span class="line">  free(plaintext); </span><br><span class="line">  return key;  // find the most probable key latter c. </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/690aa174jw1eq93nk7ucyj20kb0cqjzx.jpg" alt="Figure 3.3"></p>
<center><em>Figure 3.3 find most probable key character</em></center>

<p>  From the result in figure 3.3, we can also see that no matter what character was set as key character, Ke, the probability that two randomly chosen letters are the same, is always 0.065136. So we can’t get the most probable key character from Ke.<br>  After “key length” times repetition, we can get the most probable key word, which was shown in figure 3.4.<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93o4zxhpj20n703iq4a.jpg" alt="Figure 3.4"></p>
<center><em>Figure 3.4 find the most probable key word</em></center>

<h3 id="Decrypt-the-cipher"><a href="#Decrypt-the-cipher" class="headerlink" title="Decrypt the cipher"></a>Decrypt the cipher</h3><p>  For a given key word, we will get the matched plain text using decrypt function, which was shown below. The result was shown in figure 3.5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*decrpty the viginer ciphertext*/ </span><br><span class="line">void decrypt(char *ciphertext, char *key, char* plaintext) </span><br><span class="line">&#123; </span><br><span class="line">  int    i   ; </span><br><span class="line">  int    j   ; </span><br><span class="line">  int offset ; </span><br><span class="line">  i =    0   ; </span><br><span class="line">  j =    0   ; </span><br><span class="line">  while(ciphertext[i] != &apos;\n&apos; &amp;&amp; ciphertext[i] != &apos;\0&apos;) </span><br><span class="line">  &#123; </span><br><span class="line">    offset = key[j] -(int)(&apos;a&apos;); </span><br><span class="line">    if((ciphertext[i] - (int)&apos;a&apos; - offset) &lt; 0) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[i] = ciphertext[i] - offset + 26; </span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[i] = ciphertext[i] - offset;  //it seems that we can&apos;t modify plaintext </span><br><span class="line">    &#125; </span><br><span class="line">    i++; </span><br><span class="line">    j++; </span><br><span class="line">    if(key[j] == &apos;\n&apos; || key[j] == &apos;\0&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      j = 0; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  plaintext[i] = &apos;\0&apos;; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93ojl9fhj210i0alww7.jpg" alt=""></p>
<center><em> Figure 3.5 decryption</em></center>

<p>After decryption, we finally break viginere and get the plaintext.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1]. <a href="http://en.wikipedia.org/wiki/Letter_frequency" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Letter_frequency</a><br>[2]. <a href="http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher</a><br>[3]. <a href="http://sancy.univ-bpclermont.fr/~guitton/enseignements/admin.html" target="_blank" rel="noopener">http://sancy.univ-bpclermont.fr/~guitton/enseignements/admin.html</a></p>
<p>Note:  All the source code was put in <a href="https://github.com/ShelmyLin/network_security" target="_blank" rel="noopener">my github</a></p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/12/30/break_vigenere/" data-id="cjpf4ch8x000cbh4z1t3h4v2w" class="article-share-link">Share</a>
            
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Network-Security/">Network Security</a></li></ul>

          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-github_start" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/10/22/github_start/">How to use github in ubuntu</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-10-22T13:13:00.000Z" itemprop="datePublished">Oct 22, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假如现在我电脑里有某个工程项目TestProject，里面有很多代码，我想把它传到Github上，方便找工作的时候别人查看。</p>
<p>#提前准备：Github 帐号</p>
<p>注册地址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>ubuntu下安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git：sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<h1 id="第一步：安装git和一些简单的配置"><a href="#第一步：安装git和一些简单的配置" class="headerlink" title="第一步：安装git和一些简单的配置"></a>第一步：安装git和一些简单的配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lin@lin-K40IE:~$ sudo apt-get install git</span><br><span class="line">lin@lin-K40IE:~$ git config --global user.name ShelmyLin                  ## ShelmyLin是我的Github用户名。</span><br><span class="line">lin@lin-K40IE:~$ git config --global user.email linxiongmin@gmail.com     ## 这个是我的Gmail邮箱。</span><br></pre></td></tr></table></figure>
<h1 id="第二步：建立新的Repository"><a href="#第二步：建立新的Repository" class="headerlink" title="第二步：建立新的Repository"></a>第二步：建立新的Repository</h1><p>到Github个人主页，创建新的Repository,如图1，图2和图3所示。<br><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq71eix0qqj20wn05475v.jpg" alt="图1  创建新的Repository"></p>
<center><em>图1 创建新的Repository</em> </center>

<p><img src="http://ww1.sinaimg.cn/large/690aa174jw1eq71fis0e4j20ou0dsq4r.jpg" alt="图2 配置Repository"></p>
<center><em>图2 配置Repository</em></center>

<p><img src="http://ww1.sinaimg.cn/large/690aa174jw1eq71fupuoxj20nh0b9q4j.jpg" alt="图3 Repository配置完成"></p>
<center><em>图3 Repository配置完成</em></center>

<h1 id="第三步：将新建的Repository-clone到本地。"><a href="#第三步：将新建的Repository-clone到本地。" class="headerlink" title="第三步：将新建的Repository clone到本地。"></a>第三步：将新建的Repository clone到本地。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lin@lin-K40IE:~$ git clone https://github.com/ShelmyLin/MyProject</span><br><span class="line">``</span><br><span class="line">完成后，当前文件夹下会多出MyProject/。如图4所示。</span><br><span class="line"></span><br><span class="line">![图4  将新建的Repository clone到本地](http://ww3.sinaimg.cn/large/690aa174jw1eq71gev2w2j20k703v0ty.jpg)</span><br><span class="line">&lt;center&gt;*图4 将新建的Repository clone到本地*&lt;/center&gt;</span><br><span class="line"></span><br><span class="line"># 第四步：上传代码。</span><br><span class="line"></span><br><span class="line">用cp命令，将所有的代码拷贝到MyProject/。下面以上传hello.c为例说明。</span><br></pre></td></tr></table></figure>
<p>lin@lin-K40IE:~/MyProject$ git add hello.c<br>lin@lin-K40IE:~/MyProject$ git commit -m ‘hello github’<br>lin@lin-K40IE:~/MyProject$ git push origin master<br><code>`</code><br>过程如图5所示，其中nano hello.c的意思是创建一个hello.c的文件，这里因为没有文件，所以随意创建一个。git push origin master命令之后会要求输入Github的用户名和密码。我这里是ShelmyLin。</p>
<p><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq71hayj9lj20gp06dtb2.jpg" alt="图5 上传代码"></p>
<center><em>图5 上传代码</em></center><br>这时候，到自己的Github网站上，便可看到上传成功的hello.c文件。如图6所示。<br><br><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq71hwm7obj20mm06wq3w.jpg" alt="图6 hello.c上传成功"><br><center><em>图6 hello.c上传成功</em></center>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/10/22/github_start/" data-id="cjpf4ch7p0006bh4zbhgseort" class="article-share-link">Share</a>
            
            
          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-projects/Temperature_Detecting_of_Industry_Coal_Yard" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/08/28/projects/Temperature_Detecting_of_Industry_Coal_Yard/">基于红外的圆形煤仓表面温度监测系统的研究与实现</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-08-29T06:20:00.000Z" itemprop="datePublished">Aug 28, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>实践证明,对于圆形煤仓而言,煤仓煤炭温度的监测是煤仓安全管理工作的重中之重,特别是在褐煤等燃点较低的煤种而言,极易发生自燃,造成巨大的经济损失,所以,高效、准确的测量煤仓中煤堆的表面温度是各煤炭使用单位的迫切需求。传统的温度监测方法是利用点接触式温度传感器来进行温度测量,但是这种方法测量面积小,测量设备安装维护复杂,并且传感器易被外力损坏,不利于煤仓安全工作的进行。红外热像技术是目前较实用的非接触式测温技术,有监测范围广、扫描周期短、精度高等优点,在煤仓温度监测上有着巨大的应用前景。</p>
</blockquote>
<blockquote>
<p>根据圆形煤仓的实际需求,本文研究设计了一种基于红外的煤仓表面温度检测系统。该系统包含了监控中心、司机室、堆料机端 3 个功能区域。在堆料机端部署红外热像仪及工控机,辅以角度传感器及网络通信设备,完成温度数据的获取工作。在司机室部署工控机、网络设备及控制开关,可以实时远程控制堆料机端的运行。在监控中心部署服务器,完成温度数据的处理、存储及煤仓安全管理的相应功能。同时,在硬件设备基础上,对煤仓表面温度的获取、存储、处理及展示进行了研究、分析与设计,最终开发了一套用于煤仓表面温度监测的系统软件。</p>
</blockquote>
<blockquote>
<ul>
<li>关键词: 煤仓测温,红外成像,嵌入式系统,工业检测</li>
</ul>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/690aa174gw1euf3bgw2vjj20dq0a8taa.jpg" alt="圆形煤仓示意图"></p>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="系统方案"><a href="#系统方案" class="headerlink" title="系统方案"></a>系统方案</h2><p>圆形煤仓的煤炭温度监控需要考虑煤仓的大小及煤炭的实际堆积情况,煤仓半径为 60m,在煤炭堆积最高情况下,煤堆顶角最大角度为 95±5° ,使用单个热像仪无法同时满足测量精度与测量角度的要求,所以本文设计了一套使用双热像仪进行温度测量的圆形煤仓红外温度测量方案,方案的运行流程如下所示。<br><img src="http://ww4.sinaimg.cn/large/690aa174gw1euf3nfyaekj20b90a4t8w.jpg" alt="系统方案"></p>
<h2 id="双红外热像仪测量"><a href="#双红外热像仪测量" class="headerlink" title="双红外热像仪测量"></a>双红外热像仪测量</h2><p>在圆形煤仓中使用单个热像仪无法完成对煤仓半径上所有点的温度测量,所以在本系统中使用双热像仪 360° 扫描的测量方案,单个热像仪负责扫描煤仓半径上一半的温度数据,同时通过数据处理进行双热像仪的数据拼接,以获得煤仓半径上的全部温度数据,测量示意图如下图所示。<br><img src="http://ww1.sinaimg.cn/large/690aa174gw1euf3o5gjujj20fj06kmxn.jpg" alt="双红外热像仪测量"></p>
<h2 id="堆料机端软件流程"><a href="#堆料机端软件流程" class="headerlink" title="堆料机端软件流程"></a>堆料机端软件流程</h2><p>堆料机端采集程序是红外温度监测系统的重要组成部分之一,其主要任务是负责角度及温度数据的采集工作。在硬件开机后,本程序将自行启动运行。程序启动后,将首先利用命令启动红外热像仪 IPC 进程,用于通过 IPC 方式获取红外温度数据,接着读取配置文件信息,通过读取的配置数据初始化所有控件,初始化完成后,系统将进行自检,检查红外热像仪连接情况、角度模块串口通信情况、本地数据库连接情况,检查完成后,将建立四类线程,主线程用于显示红外温度图像以及启动各定事情运行,串口线程读取并更新角度信息,通信线程建立 TCP连接后用于收发数据,数据处理线程在角度更新后更新处理温度信息。堆料机端软件流程图如下图所示。<br><img src="http://ww2.sinaimg.cn/large/690aa174gw1euf3gq5v12j20mr0ojwfv.jpg" alt="堆料机端软件流程图"></p>
<h2 id="监控中心软件流程"><a href="#监控中心软件流程" class="headerlink" title="监控中心软件流程"></a>监控中心软件流程</h2><p>首先,监控中心端软件启动后将根据配置文件进行初始化,并检查数据库连接性,若初始化失败,系统将会将错误信息记录进 Log 文件,并结束程序运行。在自检通过后,系统进程初始化各定时器并通过调用 System.Thread 类中的ThreadStart 方法和 Thread 方法建立通信线程,与堆料机端不同的是,在监控中心中建立的线程需要将线程属性设置为后台线程,通信线程在后台将与堆料机端程序建立 TCP 连接,建立连接后将程序对应信号量置位表示连接已建立,接着通信线程负责处理信息的发送与接收。主线程将连接到堆料机数据库,若连接成功将启动另一线程,此线程将检查堆料机端数据是否有当日温度角度数据,若有新数据,线程将处理这些数据,合成红外温度图像。主线程在检查数据库后,将会将堆料机端未同步数据同步至监控中心数据库,并启动各定时器以定时检查各项连接及数据库数据同步情况。接着主线程将显示主界面并通过定时器定时刷新界面红外温度数据。在操作人员选择退出系统后,软件将再一次进行数据同步,同步完成后退出系统。监控中心软件流程图如下图所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/690aa174gw1euf3idw59mj20ku0ndwfw.jpg" alt="监控中心软件流程图"></p>
<h2 id="司机室软件流程"><a href="#司机室软件流程" class="headerlink" title="司机室软件流程"></a>司机室软件流程</h2><p>司机室端程序的作用是对煤仓当前温度情况进行监控,所以其程序在功能上时监控中心端程序的简化版本。司机端程序是在监控中心端程序基础上根据需求进行修改。在司机室端并无数据同步的需求,所以将监控中心端程序数据检查同步的功能去除,对于当前日期温度数据读取保留,用于合成当前煤仓温度图像。将报表生成等功能做出裁剪,去除报表生成及打印功能。同时根据设计方案,将监控中心端历史记录查询功能做出修改,去除最高温度历史查询、单日查询功能,保留单点历史查询。司机室端程序其余部分与监控中心端相同,其主界面如下图所示。<br><img src="http://ww1.sinaimg.cn/large/690aa174gw1euf3f7wng4j20jv0hc3zb.jpg" alt="司机室软件流程"></p>
<h2 id="红外温度图像合成流程"><a href="#红外温度图像合成流程" class="headerlink" title="红外温度图像合成流程"></a>红外温度图像合成流程</h2><p><img src="http://ww4.sinaimg.cn/large/690aa174gw1euf3kfrx3cj20ip0ogmy2.jpg" alt="红外温度图像合成流程"></p>
<h1 id="系统测试与结果图示"><a href="#系统测试与结果图示" class="headerlink" title="系统测试与结果图示"></a>系统测试与结果图示</h1><p>煤仓表面温度监测系统最重要的功能是对煤仓表面温度的测量,所以系统的红外温度图像的测量效果是系统的重要指标。通过对比圆形煤仓表面温度监测系统的红外温度图像,可以进行系统的监控效果测试,在不同时期的系统生成的煤仓红外温度图像如下图所示,其中左图为初始状态煤仓温度,右图为使用工程机械将煤仓高温部分区域表面煤炭运走后的红外温度图像,从两张图像的对比中,我们可以明显的发现在红外图像的 240° 至 255° 区域在煤炭进行处理前后的明显色彩变化,能够明确的区分出煤仓不同区域的温度情况。<br><img src="http://ww3.sinaimg.cn/large/690aa174gw1euf3rrnp6kj20z90bxgoj.jpg" alt="煤仓红外图像测量对比图"></p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/08/28/projects/Temperature_Detecting_of_Industry_Coal_Yard/" data-id="cjpf4ch9e000xbh4z957vmdue" class="article-share-link">Share</a>
            
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/embedded-system-programming-database-network/">embedded system programming - database - network</a></li></ul>

          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-computer_system/computer_system_deep_understanding_04" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/08/27/computer_system/computer_system_deep_understanding_04/">深入理解计算机系统_信息的表示与处理</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-08-27T17:34:00.000Z" itemprop="datePublished">Aug 27, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <p>1.对于无符号与有符号之间的强制类型转化，低层的位表示不变。</p>
<p>2.C语言在执行运算的时候，如果他的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式的将有符号参数强制转化为无符号参数，然后再执行运算。<br>例如2147483647 &gt; -2147483647-1<br>但是，2147483647U &lt; -2147483647-1       (注意，2^31=2147483648）<br>因为，第二个运算涉及有符号与无符号的运算，C语言会隐式的将有符号参数强制转化为无符号参数，故-2147483647-1=-2147483648，位表示为10000…..0000，在无符号数里面，即为2147483648，所以才会有2147483647U &lt; -2147483647-1 这样的错误产生。</p>
<p>3.将一个较小的数据类型转化为一个较大的数据类型。<br>对于无符号数，只需开头补零。<br>对于有符号数，只需开头补最高位。<br>例如，原始值为11001000，转化到最高位就是1111111111001000，即在前面补最高位（这里原始值的最高位为1）。<br>解释：补出的位数与原始值的最高位合计起来，其值刚好不影响结果。<br>再比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short sx = -12345;</span><br><span class="line">unsigned int sy = sx;</span><br></pre></td></tr></table></figure></p>
<p>那么sy的结果是多少呢？<br>分析：short型的是2位,unsigned int 是4位。<br>12345 = ox3039 = 0011000000111001,取反加一得-12345的存储值：1100111111000111 = oxcfc7<br>按最高位补开头，<br>sy = 1111111111111111 1100111111000111 = 4294954951</p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/08/27/computer_system/computer_system_deep_understanding_04/" data-id="cjpf4ch97000lbh4zb08kw5ul" class="article-share-link">Share</a>
            
            
          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-projects/fpga" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/07/20/projects/fpga/">基于FPGA的体感控制</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-07-21T06:20:00.000Z" itemprop="datePublished">Jul 20, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>本设计选用FPGA硬件处理信号，对图像信号的采集、存储数据同时进行,可以达到高速的并行采集、实时分析和同步存储的目的。我们采用Altera公司的Cyclone II EP2C35F672C6，为保证FPGA的稳定工作，选用 25M的时钟对TRDB-D5M   CMOS摄像头的图像信号进行并行采集。将采集到的图像调整到640×480的大小并将数据暂时存入SDRAM中。同时VGA控制模块读取SDRAM中的信息，将视频信息显示在VGA屏上。<br>本设计利用皮肤检测不断对视频信息中的皮肤进行追踪，从而实现手势追踪，并在左右屏中算出皮肤的中心点作为手部信息的坐标点，以此作为手势信息。根据上述手势信息，产生对小车的控制命令，通过Nrf24L01无线模块发送至小车。小车接受信息后，作出相应行走动作。<br>本系统提供按键便于用户进进行功能选择，如显示真实视频信息、皮肤信息、虚拟小人等。皮肤信息用于不同背景环境下手势动作的调整，减少了系统的误判。</p>
</blockquote>
<blockquote>
<ul>
<li>关键词: PGA，体感识别，皮肤检测</li>
</ul>
</blockquote>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="系统方案"><a href="#系统方案" class="headerlink" title="系统方案"></a>系统方案</h2><p>该系统主要由FPGA体感识别系统和MSP430小车系统两个部分组成。<br><img src="http://ww1.sinaimg.cn/large/690aa174gw1eufrcn6vncj20da07twet.jpg" alt="系统方案"><br>在FPGA体感识别系统中，首先通过D5M采集视频信息，因为该摄像头采集到的图像是RAW类型的图像，不便于VGA显示，所以必须把RAW图像转化为RGB模式的图像，存入SDRAM中，以便VGA显示时使用。在SDRAM控制时使用了FIFO的形式，实现了SDRAM的多接口写入和读出。从SDRAM中读出的RGB信息，一方面可以送至VGA控制模块中，当（SW[17]&amp;&amp;~SW[16]）==1时，显示视频信息；另一方面送至皮肤检测模块，将检测为皮肤的区域颜色设为白色，中心点为红色，非皮肤区域为黑色，当（~SW[17]&amp;&amp;~SW[16]）==1时，显示皮肤信息。皮肤检测获得的手势信息一方面送至虚拟小人显示模块，该模块利用Bresenham算法画出虚拟小人，存于SRAM中，当SW[16]==1时，显示虚拟小人；另外一方面送至小车控制模块，根据手势信息在屏幕上的位置信息，利用无线传感器给小车发送行走命令。</p>
<p>MSP430小车系统由MSP430F499控制器，NRF24L01无线模块、L297+L298组合为小车驱动器和二项四拍步进电机组成。MCU不断读取NRf24L01接收端的信息，根据受到的指令，分别给驱动器不同频率的方波和方向信息。驱动器将不同频率的方波转换成不同频率的PWM波，从而实现了小车的前进、后退、加速、减速、转弯等动作。</p>
<h2 id="皮肤检测模块"><a href="#皮肤检测模块" class="headerlink" title="皮肤检测模块"></a>皮肤检测模块</h2><p>在视频信息中，每帧中图像的像素点都有R、G和B三个分量的值，将R、G和B转换成YUV格式，公式如下：<br>           Y=（R+2G+B）/4，U=R-G，V=B-G<br>经过多次实验得出，当像素点符合100 &lt; U &lt; 500 时属于皮肤的颜色范围。当像素点符合100 &lt; U &lt; 500且R &gt; B时，我们则认为该像素点为皮肤。<br>利用上述思想，对视频信息处理后，可得出皮肤信息，算出左右区域皮肤像素点位置的平均值，视为左臂和右臂的位置信息。根据左臂和右臂在屏幕上的位置信息，产生小车控制信息，然后对小车进行无线控制。同时根据左臂和右臂的位置信息，利用Bresenham算法从设定好的图表中划出简化的人形。</p>
<h1 id="系统测试与结果图示"><a href="#系统测试与结果图示" class="headerlink" title="系统测试与结果图示"></a>系统测试与结果图示</h1><p>当控制者双手摊开，水平朝外时，位于FPGA上的皮肤检测模块检测出双手的位置，绘制皮肤点集，如图4.1中图所示，图中白色标注点为皮肤点，红色标注点为皮肤中心点。同时，系统还会绘制模拟小人以显示控制者的动作，如图1右图所示，控制者并拢双手，动画小人也并拢双手，此外，系统还提供了硬件按键，使得控制者可以在皮肤点集图和模拟小人图之间流畅切换。经过反复测试，系统能成功快速识别出启动动作，识别率达90%，位于小车上的无线模块接收到FPGA发送过来的前进信息后，小车开始启动，实验表明，小车反映速度极快，能迅速对FPGA的控制指令做出反映。<br><img src="http://ww1.sinaimg.cn/large/690aa174gw1eufrgnis9gj208q02474a.jpg" alt="图 1"></p>
<p>小车前进动作的检测如图2所示，当控制者双手平放并保持向上托举的状态时，位于FPGA上的皮肤检测模块检测出双手的位置，绘制皮肤点集，如图4.2中图所示，图中白色标注点为皮肤点，聚集在屏幕上部分，系统成功检测出托举动作，经反复实验，该动作识别率达98%，无线模块接收到FPGA发送过来的前进信息后，做出前进动作命令，小车前进。<br>除了控制前进动作以外，系统还创新性的添加进了速度控制机制，控制者双手托举得越高，皮肤检测模块最终计算出的小车行进速度就越快，同时，为了防止小车速度过快带来的前进不稳定的问题，系统设置了最高运行速度阈值1m/s，当计算出的速度值高于阈值时，将按阈值替代处理。</p>
<p><img src="http://ww3.sinaimg.cn/large/690aa174gw1eufrimy44ej208q0270sq.jpg" alt="图 2"></p>
<p>小车的后退动作检测原理类似前进动作，控制者双手摊开，向下平放，如图3所示，FPGA皮肤检测模块检测出皮肤点集，并绘制于屏幕下方，动画小人模拟相应的动作。经反复实验，该动作识别率达92%。<br><img src="http://ww3.sinaimg.cn/large/690aa174gw1eufrjdx4w2j208q020jrd.jpg" alt="图 3"></p>
<p>控制者双手摊开并且左手放置高于右手时，代表发出小车左转命令，如图4所示，FPGA皮肤检测模块检测出皮肤点集分别位于屏幕左下角和屏幕右上角，动画小人抬高左手，放低右手，成功模拟出控制者的手势。经实验，该动作识别率达95%。</p>
<p><img src="http://ww2.sinaimg.cn/large/690aa174gw1eufrjt2vcuj208q023aa2.jpg" alt="图 4"></p>
<p>小车右转实现方法类似左转，控制者双手摊开并且右手放置高于左手，代表发出小车右转命令，如图5所示，FPGA皮肤检测模块检测出皮肤点集分别位于屏幕左上角和屏幕右下角，动画小人抬高左手，放低右手，成功模拟出控制者的手势。经实验，该动作识别率达94%。<br><img src="http://ww4.sinaimg.cn/large/690aa174gw1eufrkch7hfj208q026aa1.jpg" alt="图 5"></p>
<p>小车的刹车与前几个动作较为不同，控制者双手合拢，掌心水平朝外，如图6所示，皮肤检测模块检测出皮肤点集位于屏幕中下方，动画小人作停止状态.<br><img src="http://ww4.sinaimg.cn/large/690aa174gw1eufrkydf8kj208q02a74a.jpg" alt="图 6"></p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/07/20/projects/fpga/" data-id="cjpf4ch9f000ybh4zhr7hvfh4" class="article-share-link">Share</a>
            
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Embedded-system-programming-FPGA-Network/">Embedded system programming - FPGA - Network</a></li></ul>

          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-computer_system/computer_system_deep_understanding_02" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/04/09/computer_system/computer_system_deep_understanding_02/">深入理解计算机系统_C语言中的位运算</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-04-10T04:31:00.000Z" itemprop="datePublished">Apr 09, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>C语言中的位运算，即将数值按位做或、与、取反、异或、同或等运算。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">void show_byte(unsigned char* start,int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%.2x&quot;,start[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int data1 ,data2 ;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;data1);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;data2);</span><br><span class="line">	short m_Result;</span><br><span class="line">	printf(&quot;%d按位存储为：&quot;,data1);</span><br><span class="line">	show_byte((unsigned char*)&amp;data1,sizeof(int));</span><br><span class="line">	printf(&quot;%d按位存储为：&quot;,data2);</span><br><span class="line">	show_byte((unsigned char*)&amp;data2,sizeof(int));</span><br><span class="line">	m_Result = data1&amp;data2;</span><br><span class="line">	printf(&quot;按位与运算：%d &amp; %d = %d ，按位存储为：&quot;,data1,data2,m_Result);</span><br><span class="line">	show_byte((unsigned char*)&amp;m_Result,sizeof(int));</span><br><span class="line"></span><br><span class="line">	m_Result = data1|data2;</span><br><span class="line">	printf(&quot;按位或运算%d | %d = %d，按位存储为：&quot;,data1,data2,m_Result);</span><br><span class="line">	show_byte((unsigned char*)&amp;m_Result,sizeof(int));</span><br><span class="line"></span><br><span class="line">	m_Result = ~data1;</span><br><span class="line">	printf(&quot;按位取反运算~ %d = %d，按位存储为：&quot;,data1,m_Result);</span><br><span class="line">	show_byte((unsigned char*)&amp;m_Result,sizeof(int));</span><br><span class="line"></span><br><span class="line">	m_Result = data1^data2;</span><br><span class="line">	printf(&quot;按位异或运算%d ^ %d = %d，按位存储为：&quot;,data1,data2,m_Result);</span><br><span class="line">	show_byte((unsigned char*)&amp;m_Result,sizeof(int));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq72fd8z24j20it0cajsf.jpg" alt=""></p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/04/09/computer_system/computer_system_deep_understanding_02/" data-id="cjpf4ch94000hbh4z4gk5xk0l" class="article-share-link">Share</a>
            
            
          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-computer_system/computer_system_deep_understanding_03" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/04/09/computer_system/computer_system_deep_understanding_03/">深入理解计算机系统_Hello World的一生</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-04-10T04:31:00.000Z" itemprop="datePublished">Apr 09, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一个Hello.c程序如表所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(“Hello World\n”);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个Hello World程序，看似简单，可是为了让它完成运行，需要系统的各个组成部分协调工作，本文将通过跟踪Hello World短暂的一生，来揭秘程序运行的奥义。</p>
<h1 id="Hello-程序生成过程"><a href="#Hello-程序生成过程" class="headerlink" title="Hello 程序生成过程"></a>Hello 程序生成过程</h1><p>首先，为了将Hello.c变成可执行的二进制目标文件，需要将其推入加工车间—编译系统中进行加工，加工过程如图1.1所示。<br><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq720moecvj20lo0as752.jpg" alt=""></p>
<center> <em>图1.1编译系统</em> </center>

<h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><p>预编译器（cpp）根据以字符#开头的命令，将头文件stdio.h的内容直接插入到Hello.c文件中，最终的得到一个以i为扩展名的C文件—Hello.i文件。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p>编译器（ccl）将Hello.i文件翻译成文本文件Hello.s，这是个汇编语言程序。注意，汇编语言是计算机底层世界通用通用的语言，不同的高级语言、不同的编译器，最终得到的还是一样的汇编语言。</p>
<h2 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h2><p>汇编器（as）将Hello.s文件翻译成机器语言指令，并将结果保存到二进制文件Hello.o，后者的字节编码是机器语言指令而不是字符。</p>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><p>这里的Hello World程序调用了printf函数，它是每个C编译器都会提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须通过链接合并到我们的Hello.o文件中，链接器（ld）就是做这个工作的，它最终会输出一个可执行目标文件Hello，这个可执行目标文件可以被加载到内存中，由系统执行。</p>
<p>以上就是Hello World的生成过程，现在讲讲当系统开始执行这个程序到屏幕完整的输出这句激动人性的“Hello World”的时候，计算机内部系统都干了些什么？<br> 首先，我们先看看一个典型的计算机系统的硬件组成图，如图1.2所示。<br><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq728wa8vcj20l20ha0uz.jpg" alt=""></p>
<center> <em>图1.2 一个典型的计算机系统的硬件组成</em> </center>

<h1 id="Hello-程序执行过程"><a href="#Hello-程序执行过程" class="headerlink" title="Hello 程序执行过程"></a>Hello 程序执行过程</h1><p>然后，我们开始观赏Hello程序的执行过程，主要分为三个步骤：</p>
<h2 id="从键盘读取Hello命令"><a href="#从键盘读取Hello命令" class="headerlink" title="从键盘读取Hello命令"></a>从键盘读取Hello命令</h2><p>打开终端，在Hello的目录下，通过键盘输入“./Hello”后，系统会将这些字符读入到寄存器中，如图1.3所示，然后再存放到主存储器中，如图1.4所示。<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq721snsszj20l00ha75v.jpg" alt=""></p>
<center> <em>图1.3 系统读入“./Hello”到寄存器中</em> </center>

<p><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq72219hxkj20l10h3dha.jpg" alt=""> </p>
<center><em>图1.4 系统将“./Hello”从寄存器搬到主存储器中</em></center>

<h2 id="从磁盘加载可执行文件到主存储器中。"><a href="#从磁盘加载可执行文件到主存储器中。" class="headerlink" title="从磁盘加载可执行文件到主存储器中。"></a>从磁盘加载可执行文件到主存储器中。</h2><p>当系统接收完“./Hello”命令以后，将开始执行一系列指令来加载可执行的Hello文件，将Hello目标文件中的代码和数据从磁盘复制到主存储器中，当然，这些数据包含那句“Hello World\n”。<br><img src="http://ww1.sinaimg.cn/large/690aa174jw1eq722ggluej20l60h0abi.jpg" alt=""></p>
<center><em>图1.5 系统从磁盘加载可执行文件到主存储器中</em></center>

<h2 id="将输出字符串从内存写到显示器"><a href="#将输出字符串从内存写到显示器" class="headerlink" title="将输出字符串从内存写到显示器"></a>将输出字符串从内存写到显示器</h2><p>一旦目标文件Hello中的代码和数据被加载到内存中，处理器就开始执行Hello程序的main程序中的机器语言指令，这些指令将“Hello World\n”字符节中的字节从主存复制到寄存器文件，如图1.6所示。<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq722oty28j20lk0gzta9.jpg" alt=""></p>
<center><em>图1.6 系统将“Hello World\n”从主存复制到寄存器文件</em></center>

<p>接着，指令会继续将这次字符从寄存器文件中复制到显示设备，最终显示到屏幕上，如图1.7所示。<br><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq722vqwtrj20l00gqwg1.jpg" alt=""></p>
<center><em>图1.7 系统将“Hello World\n”从寄存器文件复制到显示设备</em></center>

<p>自此，Hello World完成了它伟大的使命！</p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/04/09/computer_system/computer_system_deep_understanding_03/" data-id="cjpf4ch96000kbh4zyvjccsw0" class="article-share-link">Share</a>
            
            
          </footer>

        </div>

        
      </article>


      




      
        

      <article id="post-windows_programming_sql2008_net" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/04/09/windows_programming_sql2008_net/">windows编程_.net对SQL Server2008数据库的读写操作</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-04-09T07:00:00.000Z" itemprop="datePublished">Apr 09, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="在头文件中定义SqlConnection"><a href="#在头文件中定义SqlConnection" class="headerlink" title="在头文件中定义SqlConnection"></a>在头文件中定义SqlConnection</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlConnection ^ConnSql;</span><br></pre></td></tr></table></figure>
<h1 id="链接SQL-Server数据库"><a href="#链接SQL-Server数据库" class="headerlink" title="链接SQL Server数据库"></a>链接SQL Server数据库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">buttonConnectToDB_Click函数为按钮“连接数据库”的响应函数。</span><br><span class="line">private: System::Void buttonConnectToDB_Click(System::Object^  sender, System::EventArgs^  e) &#123;</span><br><span class="line">			 if (Lin_BConnectedToDB == false)</span><br><span class="line">			 &#123;</span><br><span class="line">				 Lin_DataSource = textBoxDataSource-&gt;Text;</span><br><span class="line">				 Lin_DataBaseName = textBoxInitialCatalog-&gt;Text;</span><br><span class="line">				 //Windows验证访问，使用下面这行代码。</span><br><span class="line">				 String^ strConn = &quot;Data Source = &quot; + Lin_DataSource + &quot;;Initial Catalog=&quot; + Lin_DataBaseName + &quot;;Integrated  Security=True&quot;;//SQL Server链接字符串</span><br><span class="line">				 //sa账户密码访问用下面这行代码。</span><br><span class="line">				 //String^ strConn = &quot;Data Source = &quot; + Lin_DataSource + &quot;;Initial Catalog=&quot; + Lin_DataBaseName + &quot;;uid = sa;pwd = 123456&quot;;//SQL Server链接字符串</span><br><span class="line">				 ConnSql = gcnew SqlConnection(strConn); //Sql链接类的实例化</span><br><span class="line">				 try</span><br><span class="line">				 &#123;</span><br><span class="line">					 ConnSql-&gt;Open();//打开数据库</span><br><span class="line">					 if (ConnSql-&gt;State == ConnectionState::Open)</span><br><span class="line">					 &#123;</span><br><span class="line">						 Lin_BConnectedToDB = true;</span><br><span class="line">						 label15-&gt;Text = &quot;系统状态：成功连接数据库!&quot;;</span><br><span class="line">					 &#125;</span><br><span class="line">				 &#125;</span><br><span class="line">				 catch (Exception ^sb)</span><br><span class="line">				 &#123;</span><br><span class="line">					 MessageBox::Show(&quot;数据库..连不上...&quot;);</span><br><span class="line">					</span><br><span class="line">				 &#125;		 </span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br></pre></td></tr></table></figure>
<h1 id="从数据库读取数据"><a href="#从数据库读取数据" class="headerlink" title="从数据库读取数据"></a>从数据库读取数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool FormMulti::whu_ReadDataFromDB(double angle,array&lt;short&gt;^DestData)</span><br><span class="line">&#123;</span><br><span class="line">	bool m_BRead = false; </span><br><span class="line">	String ^m_AngleStr = String::Format(&quot;&#123;0:##0.0&#125;&quot;,angle);</span><br><span class="line">	String ^strSQL = &quot;SELECT  [Temperature] FROM dbo.SourceData2 where angle = &quot; + m_AngleStr;</span><br><span class="line">	array&lt;byte&gt;^ m_byte = gcnew array&lt;byte&gt;(DestData-&gt;Length*sizeof(short));</span><br><span class="line">	SqlCommand ^cmd = gcnew SqlCommand();</span><br><span class="line">	cmd-&gt;Connection = ConnSql;</span><br><span class="line">	cmd-&gt;CommandText = strSQL;</span><br><span class="line">	SqlDataReader ^sdr = cmd-&gt;ExecuteReader();</span><br><span class="line">	while(sdr-&gt;Read())//读最新的数据//</span><br><span class="line">	&#123;</span><br><span class="line">		sdr-&gt;GetBytes(0,0,m_byte,0,m_byte-&gt;Length);</span><br><span class="line">		System::Buffer::BlockCopy(m_byte,0,DestData,0,m_byte-&gt;Length);</span><br><span class="line">		m_BRead = true;</span><br><span class="line">	&#125;</span><br><span class="line">	sdr-&gt;Close();</span><br><span class="line">	return m_BRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="写入数据到SQL-Server数据库"><a href="#写入数据到SQL-Server数据库" class="headerlink" title="写入数据到SQL Server数据库"></a>写入数据到SQL Server数据库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool FormMulti::whu_SaveDataToDB()</span><br><span class="line">&#123;</span><br><span class="line">	DateTime ^now = DateTime::Now;</span><br><span class="line">	System::Windows::Forms::DateTimePicker^  dateTimePicker2 = gcnew System::Windows::Forms::DateTimePicker();</span><br><span class="line">	String ^m_time = now-&gt;ToString(&quot;yyyy-MM-dd HH:mm:ss:fff&quot;);</span><br><span class="line">	////写入：</span><br><span class="line">	array&lt;short&gt; ^m_AngleWithValues = gcnew array&lt;short&gt;(Lin_AngleWithValues-&gt;Length/(360*AngleAccuracy));</span><br><span class="line">	for (int i=0;i&lt;360*AngleAccuracy;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int pos = i*(Lin_AngleWithValues-&gt;Length/(360*AngleAccuracy));</span><br><span class="line">		short m_VerifyValue = 0xffff;</span><br><span class="line">		if(Lin_AngleWithValues[pos]==m_VerifyValue)</span><br><span class="line">		&#123;</span><br><span class="line">			for (int j=0;j&lt;m_AngleWithValues-&gt;Length;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				m_AngleWithValues[j] = Lin_AngleWithValues[j+pos];</span><br><span class="line">			&#125;</span><br><span class="line">			double My_Angle = ((double)Lin_AngleWithValues[pos+1])/(double)AngleAccuracy;</span><br><span class="line">			//存入数据//</span><br><span class="line">			String ^m_InsertImageSQL = &quot;insert into dbo.SourceData2(time,angle,Temperature) values(@time,@angle,@Temperature)&quot;;</span><br><span class="line">			SqlCommand ^CmdObj = gcnew SqlCommand(m_InsertImageSQL, ConnSql);</span><br><span class="line">			//写入：</span><br><span class="line">			CmdObj-&gt;Parameters-&gt;Add(&quot;@time&quot;,SqlDbType::DateTime);</span><br><span class="line">			CmdObj-&gt;Parameters-&gt;Add(&quot;@angle&quot;, SqlDbType::Float );</span><br><span class="line">			CmdObj-&gt;Parameters-&gt;Add(&quot;@Temperature&quot;, SqlDbType::Image);</span><br><span class="line">			CmdObj-&gt;Parameters[&quot;@time&quot;]-&gt;Value = now;</span><br><span class="line">			CmdObj-&gt;Parameters[&quot;@angle&quot;]-&gt;Value = My_Angle;</span><br><span class="line">			array&lt;Byte&gt;^ m_ByteDestData = gcnew array&lt;Byte&gt;(sizeof(short)*(m_AngleWithValues-&gt;Length));</span><br><span class="line">			System::Buffer::BlockCopy(m_AngleWithValues,0,m_ByteDestData,0,m_ByteDestData-&gt;Length);</span><br><span class="line">			CmdObj-&gt;Parameters[&quot;@Temperature&quot;]-&gt;Value = m_ByteDestData;</span><br><span class="line">			CmdObj-&gt;ExecuteNonQuery();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="断开SQL-Server数据库"><a href="#断开SQL-Server数据库" class="headerlink" title="断开SQL Server数据库"></a>断开SQL Server数据库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private: System::Void buttonDisConnectToDB_Click(System::Object^  sender, System::EventArgs^  e) &#123;</span><br><span class="line">			 if (Lin_BConnectedToDB)</span><br><span class="line">			 &#123;</span><br><span class="line">				 ConnSql-&gt;Close();//关闭数据库</span><br><span class="line">				 Lin_BConnectedToDB = false;</span><br><span class="line">				 label15-&gt;Text = &quot;系统状态：未连接数据库!&quot;;</span><br><span class="line"></span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br></pre></td></tr></table></figure>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://linxiongmin.com/2014/04/09/windows_programming_sql2008_net/" data-id="cjpf4ch7t000abh4z0vbmgykz" class="article-share-link">Share</a>
            
            
          </footer>

        </div>

        
      </article>


      




      


      



    </div>
  </div>
</div>


  </div>

  <footer class="page-footer grey darken-2">
    <div class="footer-copyright">
      <div class="container">
        &copy; 2018 Xiongmin Lin

        <div class="right">
          Powered by <a href="http://hexo.io/" rel="nofollow" class="white-text" target="_blank">Hexo</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="/js/app.js"></script>

</body>
</html>
