<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Tag: Network Security | Xiongmin Lin</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Hi, welcome to Xiongmin Lin&apos;s website">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiongmin Lin">
<meta property="og:url" content="http://yoursite.com/blog/tags/Network-Security/index.html">
<meta property="og:site_name" content="Xiongmin Lin">
<meta property="og:description" content="Hi, welcome to Xiongmin Lin&apos;s website">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xiongmin Lin">
<meta name="twitter:description" content="Hi, welcome to Xiongmin Lin&apos;s website">

  
    <link rel="alternate" href="/atom.xml" title="Xiongmin Lin" type="application/atom+xml">
  

  
  <!--[if lte IE 10 ]><link rel="shortcut icon" href="/images/favicon.ico"><![endif]-->
  <!--[if !IE]><!-->
  <link rel="shortcut icon" href="/images/favicon.png">

  <meta name="msapplication-TileImage" content="/images/favicon.png">
  <meta name="msapplication-TileColor" content="#000000">

  <link rel="apple-touch-icon" href="/images/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png">

  <link rel="icon" sizes="256x256" href="/images/favicon.png">
  <!--<![endif]-->
  

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro|Material+Icons|Raleway:400,300,700" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="/css/vendors.css">
  <link rel="stylesheet" href="/css/style.css">
  


  <script src="/js/vendors.js"></script>

  <script>
    define('jquery', function () {
      return window.jQuery;
    });
  </script>


</head>
<body>

  <div class="navbar-fixed">
  <nav id="main-navbar" class="grey lighten-5 z-depth-0" role="navigation">
    <div class="nav-wrapper container">

      <a id="logo-container" href="/" class="brand-logo center-align">
        <span>Xiongmin Lin</span>
        <sub></sub>
      </a>

      <ul class="right hide-on-med-and-down">
        
          <li>
            <a class="main-nav-link" href="/">Home</a>
          </li>
        
          <li>
            <a class="main-nav-link" href="/blog">Blog</a>
          </li>
        
      </ul>

      <a href="#" data-activates="nav-mobile" class="button-collapse">
        <i class="material-icons">menu</i>
      </a>
    </div>
  </nav>
</div>

<ul id="nav-mobile" class="side-nav">
  
  <li>
    <a class="main-nav-link" href="/">Home</a>
  </li>
  
  <li>
    <a class="main-nav-link" href="/blog">Blog</a>
  </li>
  
</ul>


  <div id="main-container">
    <div class="container">
  <div class="row">
    <div class="col s12">

      
        <h2 class="header color-featured">Tag: Network Security</h2>
      

      
        

      <article id="post-break_vigenere" class="article article-type-post" itemscope="" itemprop="blogPost">

        <div class="article-inner">
          

          <header class="article-header">
          
              
  
    <h1 itemprop="name" class="header">
      <a class="article-title " href="/2014/12/30/break_vigenere/">Implementation and cryptanalysis of Vigenère</a>
    </h1>
  


          

            <div class="article-meta">
              <i class="fa fa-calendar"></i>
              <time datetime="2014-12-30T08:00:00.000Z" itemprop="datePublished">Dec 30, 2014</time>
            </div>
          </header>


          <div class="article-entry " itemprop="articleBody">
            
              <h1 id="Implementation-of-Vigenere-cipher"><a href="#Implementation-of-Vigenere-cipher" class="headerlink" title="Implementation of Vigenère cipher"></a>Implementation of Vigenère cipher</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The Vigenère cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword.</p>
<h2 id="Lab-exercise"><a href="#Lab-exercise" class="headerlink" title="Lab exercise"></a>Lab exercise</h2><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>Implement a program that asks the user for a text, and that displays it. Modify your program so that all letters are converted to lower-case, and all non-letter characters are removed.</p>
<h3 id="Main-idea"><a href="#Main-idea" class="headerlink" title="Main idea"></a>Main idea</h3><p>Getting the input text and keyword. We don’t know the length of input text and keyword, so we just use malloc and realloc function to allocate address space for input text and keyword.  If they are capital letter, change them to the lower-case. After that, removing the non-letter characters.</p>
<h3 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h3><h4 id="Input-text"><a href="#Input-text" class="headerlink" title="Input text"></a>Input text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Getting the input text and covert it using covert function.                               */</span><br><span class="line">/* to get a viginer cipher, you should input the plaintext(the longer, the better)  */ </span><br><span class="line">origintext = (char*) malloc(1000); </span><br><span class="line">printf(&quot;please input origin text \n&quot;); </span><br><span class="line">for(i = 0; (*(origintext + i) = getchar()) != &apos;\n&apos;; i++) </span><br><span class="line">&#123; </span><br><span class="line">  if((i+1) % 1000 == 0) </span><br><span class="line">  &#123; </span><br><span class="line">    origintext = (char*)realloc(origintext, strlen(origintext) + 1000); </span><br><span class="line">  &#125;   </span><br><span class="line">&#125; </span><br><span class="line">origintext[i] = &apos;\0&apos;; </span><br><span class="line">plaintext = (char*)malloc(strlen(origintext));   </span><br><span class="line">memset(plaintext, &apos;\0&apos;, strlen(plaintext)); </span><br><span class="line">convert(origintext, plaintext);</span><br></pre></td></tr></table></figure>
<h4 id="Covert-the-text"><a href="#Covert-the-text" class="headerlink" title="Covert the text"></a>Covert the text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* convert function is used to covert the original text to  plaintext, delete  * </span><br><span class="line"> * no-letter char and covert captical letter to lowercase                               */ </span><br><span class="line">void convert(char *origintext, char *plaintext) </span><br><span class="line">&#123; </span><br><span class="line">  int i, j; </span><br><span class="line">  i = 0; </span><br><span class="line">  j = 0; </span><br><span class="line">  memset(plaintext, &apos;\0&apos;, strlen(plaintext)); </span><br><span class="line">  while(origintext[i] != &apos;\0&apos;) </span><br><span class="line">  &#123; </span><br><span class="line">    if(origintext[i] &lt;= &apos;Z&apos; &amp;&amp; origintext[i] &gt;= &apos;A&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[j] = origintext[i] + 32; </span><br><span class="line">      j++; </span><br><span class="line">    &#125; </span><br><span class="line">    if(origintext[i] &lt;= &apos;z&apos; &amp;&amp; origintext[i] &gt;= &apos;a&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[j] = origintext[i]; </span><br><span class="line">      j++; </span><br><span class="line">    &#125; </span><br><span class="line">    i++; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Input-the-key-word"><a href="#Input-the-key-word" class="headerlink" title="Input the key word"></a>Input the key word</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> /*input the key word*/ </span><br><span class="line">printf(&quot;please input the key\n&quot;); </span><br><span class="line">for(i = 0,key = (char*)malloc(100); (*(key + i) = getchar()) != &apos;\n&apos;; i++) </span><br><span class="line">&#123; </span><br><span class="line">  if((i + 1) % 100 == 0) </span><br><span class="line">  &#123; </span><br><span class="line">    key=(char*)realloc(key,strlen(key)+100); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">*(key+i)=&apos;\0&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>The result was shown in figure 1.1. The plain text was about the introduction of viginere, which came from wikipedia-viginere. The keyword was set to isima.<br><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93j220hcj20zq09i4b3.jpg" alt="figure 1.1"></p>
<center><em> Figure 1.1 encryption of plain text</em> </center>

<h1 id="Cryptanalysis-key-length-estimation"><a href="#Cryptanalysis-key-length-estimation" class="headerlink" title="Cryptanalysis: key length estimation"></a>Cryptanalysis: key length estimation</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>When the key length is known, a Vigenère cipher can be broken using frequency analysis. The primary weakness of the Vigenère cipher is the repeating nature of its key. If a cryptanalyst correctly guesses the key’s length, then the cipher text can be treated as interwoven Caesar ciphers, which individually are easily broken. The Kasiski and Friedman tests can help determine the key length.</p>
<h2 id="Babbage-and-Kasiki-method"><a href="#Babbage-and-Kasiki-method" class="headerlink" title="Babbage and Kasiki method"></a>Babbage and Kasiki method</h2><p>Friedrich Kasiski was the first to publish a successful general attack on the Vigenère cipher. Charles Babbage was goaded into breaking the Vigenère cipher when John Hall Brock Thwaites submitted a “new” cipher to the Journal of the Society of the Arts. When Babbage showed that Thwaites’ cipher was essentially just another recreation of the Vigenère cipher, Thwaites challenged Babbage to break his cipher encoded twice, with keys of different length.</p>
<h2 id="Lab-work"><a href="#Lab-work" class="headerlink" title="Lab work"></a>Lab work</h2><p>  To calculate the length of key work. I removed the letters whose repetitions were less than 2 times, and then get the distance between two same strings. After that I get divisors of each distance and calculate the weight of each divisor. With highest weight, we get the most probable probable length of key word.</p>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">/* get_key_size function is used to calculate the keysize of the key                                                               */ </span><br><span class="line">/* to avoid noise, get_key_size() calculates the weight of each possible keys and the result is                      */ </span><br><span class="line">/* more precise than previous get_key_size(), which just calculates the same divisor of all possible keys    */ </span><br><span class="line">/* input:  cipher text.                                                                                                                                         */</span><br><span class="line">/* output: the most probable length of key word.                                                                                             */</span><br><span class="line">/* Same_Str struct is used to stored the information of the same strings in ciphertext */ </span><br><span class="line">struct Same_Str&#123; </span><br><span class="line">  char str[1000]; </span><br><span class="line">  int  num;             // the repetition time of each string</span><br><span class="line">  int  start[1000];   //the start position of string</span><br><span class="line">  int  end[1000];    // the end position of string, distance = end[i] – start[i], i stands for each repetition. </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int get_key_size(char* ciphertext) </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  /* step 1: initialize work*/</span><br><span class="line"></span><br><span class="line">  int size = 0; </span><br><span class="line">  int i, j, m, k, r; </span><br><span class="line">  int len = strlen(ciphertext); </span><br><span class="line">  int *keysize = malloc(sizeof(int)*strlen(ciphertext)); </span><br><span class="line">  memset(keysize, 0, sizeof(int)*strlen(ciphertext));    // if possible key size is 27, set keysize[26]=1; </span><br><span class="line">  int malloc_size = 1000; </span><br><span class="line">  struct Same_Str *same_str = malloc(sizeof(struct Same_Str) * malloc_size); </span><br><span class="line">  int str_num; </span><br><span class="line">  str_num = 0; </span><br><span class="line">  for(i = 0; i &lt; malloc_size; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    same_str[i].num = 0; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  char *block_1 = malloc(len); </span><br><span class="line">  char *block_2 = malloc(len); </span><br><span class="line"></span><br><span class="line">/* step 2: compare each string, find the same string and store the information into Same_Str struct*/</span><br><span class="line"></span><br><span class="line">  for(m = 2; m &lt; len/2 ; m++)  //m -&gt; the length of blocks to be compared </span><br><span class="line">  &#123; </span><br><span class="line">    int block_num = len -m; </span><br><span class="line">    for(i = 0; i &lt; block_num; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      memset(block_1, &apos;\0&apos;, strlen(block_1)); </span><br><span class="line">      memcpy(block_1, ciphertext + i, m+1); </span><br><span class="line">      int w = 0;                                           </span><br><span class="line">      for(j = i + 1 + m; j &lt; block_num; j++) </span><br><span class="line">      &#123; </span><br><span class="line">        if(j &gt;= block_num) break; </span><br><span class="line">        memset(block_2, &apos;\0&apos;, strlen(block_2)); </span><br><span class="line">        memcpy(block_2, ciphertext + j, m+1); </span><br><span class="line">        if(strcmp(block_1, block_2) == 0) </span><br><span class="line">        &#123; </span><br><span class="line">           w++; </span><br><span class="line">    </span><br><span class="line">           int pos = same_str[str_num].num; </span><br><span class="line">           same_str[str_num].start[pos] = i; </span><br><span class="line">           same_str[str_num].end[pos]   = j; </span><br><span class="line">           same_str[str_num].num++;           </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      if(w &gt; 0) </span><br><span class="line">      &#123; </span><br><span class="line">        sprintf(same_str[str_num].str, &quot;%s&quot;, block_1); </span><br><span class="line">        printf(&quot;No.%d, found same block: %s, %d times\n&quot;,str_num, same_str[str_num].str, same_str[str_num].num); </span><br><span class="line">        str_num++; </span><br><span class="line">        if(str_num &gt;= malloc_size) </span><br><span class="line">        &#123; </span><br><span class="line">          malloc_size += 1000; </span><br><span class="line">          same_str = realloc(same_str, sizeof(struct Same_Str) * malloc_size); </span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">      &#125; </span><br><span class="line">      //usleep(100); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  free(block_1); </span><br><span class="line">  free(block_2); </span><br><span class="line"></span><br><span class="line">  /* step 3: removed the letters whose repetitions were less than 2 times */</span><br><span class="line"></span><br><span class="line">  /* from code above, we know all possible key sizes (count: str_num), which are stored in same_str array */ </span><br><span class="line">  /*if some strs whose replication time is more than 2, then it must be the REAL str*/ </span><br><span class="line">  k = 0; </span><br><span class="line">  for(m = 0; m &lt; str_num; m++ ) </span><br><span class="line">  &#123; </span><br><span class="line">    if(same_str[m].num &gt;= 2)  // just skip weak string, one replication string </span><br><span class="line">    &#123; </span><br><span class="line">      /*the REAL str*/ </span><br><span class="line">      for(r = 0; r &lt; same_str[m].num; r++) </span><br><span class="line">      &#123; </span><br><span class="line">        int start  = same_str[m].start[r]; </span><br><span class="line">        int end    = same_str[m].end[r]; </span><br><span class="line">      	keysize[k] = end - start; </span><br><span class="line">        k++;          </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 4: get the divisors of each distance and calculate their weight */</span><br><span class="line"></span><br><span class="line">  /* get max number of key size, to malloc the array, each possible key size will be split as an        * </span><br><span class="line">   * array ptr[i] and be added with an all-0 array: weight, from the weight of each key, we know     * </span><br><span class="line">   * the most possible keysize                                                                                                               */ </span><br><span class="line">  int **ptr = malloc(sizeof(int*)*k); </span><br><span class="line">  int max   = 0; </span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">     int num = keysize[i]; </span><br><span class="line">     max     = (max &gt; num)? max : num; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  int *weight = malloc(sizeof(int) * max); </span><br><span class="line">  for(i = 0; i &lt; max ;i++) </span><br><span class="line">  &#123; </span><br><span class="line">    weight[i] = 0; </span><br><span class="line">  &#125; </span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">     int num       = keysize[i]; </span><br><span class="line">     ptr[i]        = malloc(sizeof(int)*max); </span><br><span class="line">     ptr[i][num-1] = 1 ; </span><br><span class="line">     memset(ptr[i], 0, max); </span><br><span class="line"></span><br><span class="line">     /* at first, ptr[i] = &quot;00000...00100..&quot;, after get_divisor, ptr[i] = &quot;0..1..00..100..1..100...&quot;, * </span><br><span class="line">     * where 1 means the match pos is the divisor number of keysize[i]                               */ </span><br><span class="line">     get_divisor(ptr[i], num); </span><br><span class="line">     for(j = 0; j &lt; max; j++) </span><br><span class="line">     &#123; </span><br><span class="line">       weight[j] = weight[j] + ptr[i][j]; </span><br><span class="line">     &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 5, get the most probable length of key words through weight information*/</span><br><span class="line"></span><br><span class="line">  int max_weight = 0; </span><br><span class="line">  </span><br><span class="line">  for(j = 0; j &lt; max; j++) </span><br><span class="line">  &#123; </span><br><span class="line">    if(weight[j] != 0) </span><br><span class="line">    &#123; </span><br><span class="line">      printf(&quot;weight of %d: %d\n&quot;, j+1, weight[j]); </span><br><span class="line">    &#125; </span><br><span class="line">    if(max_weight &lt; weight[j]) </span><br><span class="line">    &#123; </span><br><span class="line">      size       = j+1; </span><br><span class="line">      max_weight = weight[j]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  /*step 6, free resources*/</span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; k; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    free(ptr[i]); </span><br><span class="line">  &#125;  </span><br><span class="line">  free(keysize); </span><br><span class="line">  free(weight); </span><br><span class="line">  free(ptr); </span><br><span class="line">  free(same_str); </span><br><span class="line">  return size; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h2><p>Figure 2.1 shows the same strings that were found. Figure 2.2 shows the weight of each probable key length. We can easily find the the number 5 has highest weight 226, and the key word that we input was “isima”, so we found the right length of key word, which was shown in figure 2.3.<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93jzcphij20pc07otcg.jpg" alt="Figure 2.1"></p>
<center><em>Figure 2.1  the same strings that werefound</em></center>

<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93lfzmdbj20sk06eab5.jpg" alt="Figure 2.2"></p>
<center><em>Figure 2.2  the weight of each probable key length</em></center>

<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93lx5asrj20so07w75u.jpg" alt="Figure 2.3"></p>
<center><em>Figure 2.3 most probable key length is 5</em> </center>

<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>If the length of key word was the number like 10 whose divisors were 1, 2, 5, 10. then the number 5 will have larger or at least equal weight as number 10. It’s a problem. I am sorry but I don’t know how to solve it.    </p>
<h1 id="Cryptanalysis-probable-word-method"><a href="#Cryptanalysis-probable-word-method" class="headerlink" title="Cryptanalysis: probable word method"></a>Cryptanalysis: probable word method</h1><h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><p>For most used English words, each character has a different frequency, which was shown in figure 3.1.<br><img src="http://ww2.sinaimg.cn/large/690aa174jw1eq93mcsfp3j20rs04btas.jpg" alt="figure 3.1"></p>
<center><em>Figure 3.1 the frequency of each character in alphabet</em></center>

<h2 id="Lab-work-1"><a href="#Lab-work-1" class="headerlink" title="Lab work"></a>Lab work</h2><p>  To find the probable key word, we can detach the cipher into “key_length” part, for example, after calculation, the probable key length was 5, then we just detach the cipher into 5 parts, for the letters in each part, they have the same key character.<br>  After that, we choose 1 character from alphabet and try to decrypt each part of cipher text. Then, we compare frequency of the decryption text with the table of the most used English words, which was shown in figure 3.1. In this case, we just calculate the sample variance of the frequencies, the smaller sample variance, the better. Repeat the decryption of each characters in alphabet, we will get a minimum sample variance, then we get the most probable key character.<br>  Repeat “key length” time of the experiment, we will get the most probable key word.</p>
<h2 id="source-code-1"><a href="#source-code-1" class="headerlink" title="source code"></a>source code</h2><h3 id="Analyze-the-text-and-get-frequencies-of-each-character"><a href="#Analyze-the-text-and-get-frequencies-of-each-character" class="headerlink" title="Analyze the text and get frequencies of each character"></a>Analyze the text and get frequencies of each character</h3><p>For a given text, we can get the frequencies of each character and sample variance using anal_freq function. We can also get the probability that two randomly chosen letters are the same, which was named Ke. One of the result was shown in figure 3.2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/* anal_freq function is used to analyze the text, </span><br><span class="line">   input: </span><br><span class="line">   1. text to analyze </span><br><span class="line">   output: </span><br><span class="line">   1. the frequency of each 26 letters -&gt;m_fre[26] </span><br><span class="line">   2. The probability that two randomly chosen letters are the same -&gt; Ke </span><br><span class="line">   3. return value: the variance, to estimate the quality of decryption test. */ </span><br><span class="line"></span><br><span class="line">double anal_freq(char *text, double m_fre[26], double *Ke) </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  int i, pos; </span><br><span class="line">  int count; </span><br><span class="line"></span><br><span class="line">  /* the normal frequency for each 26 letters */ </span><br><span class="line">  double fre[26] = &#123;0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, </span><br><span class="line">                               0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749, </span><br><span class="line">                               0.07507, 0.01929, 0.00095,                0.05987, 0.06327, 0.09056, </span><br><span class="line">                               0.02758, 0.00978, 0.02360,                0.00150, 0.01974, 0.00074, &#125;; </span><br><span class="line"></span><br><span class="line">  /* the offset was set to verify that, no matter how    * </span><br><span class="line">   * you pick up a letter in an offset interval, the     * </span><br><span class="line">   * Ke results are always approximately equals to 0.067 */ </span><br><span class="line"></span><br><span class="line">  int offset      = 1; </span><br><span class="line">  double variance = 0; // to estimate the quality of decryption text </span><br><span class="line">  count = strlen(text); </span><br><span class="line"></span><br><span class="line">  /*get frequency of each letter; get Ke*/ </span><br><span class="line"></span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    m_fre[i] = 0; </span><br><span class="line">  &#125; </span><br><span class="line">  i = 0; </span><br><span class="line">  while(text[i] != &apos;\0&apos; &amp;&amp; i &lt; strlen(text)) </span><br><span class="line">  &#123; </span><br><span class="line">    pos = (int)(text[i] - &apos;a&apos;); </span><br><span class="line">    m_fre[pos]++; </span><br><span class="line">    i = i + offset; </span><br><span class="line">  &#125; </span><br><span class="line">  *Ke = 0; </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">   *Ke += (m_fre[i] * (m_fre[i] - 1)); </span><br><span class="line">  &#125; </span><br><span class="line">  count = count / offset; </span><br><span class="line"></span><br><span class="line">  *Ke = *Ke / (double)(count * (count - 1)); </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    m_fre[i] = m_fre[i] / (double)count; </span><br><span class="line">  &#125; </span><br><span class="line">  //printf(&quot;The probability that two randomly chosen letters are the same: %2.4f\n&quot;,Ke); </span><br><span class="line"></span><br><span class="line">  /*calculate the variance*/  </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    variance += pow((m_fre[i] - fre[i]), 2); </span><br><span class="line">  &#125;  </span><br><span class="line">  variance = variance / (double)25; </span><br><span class="line">  return variance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww4.sinaimg.cn/large/690aa174jw1eq93mz7ofcj20ju0cwaer.jpg" alt="figure 3.2"></p>
<center><em>Figure 3.2 analyze the text</em></center>

<h3 id="Find-most-probable-key-character"><a href="#Find-most-probable-key-character" class="headerlink" title="Find most probable key character"></a>Find most probable key character</h3><p>  Repeat the decryption of each characters in alphabet, we will get a minimum sample variance, then we get the most probable key character. The result was shown in figure 3.3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*the find_each_key_letter function is used to find a most probable key letter for a given ciphertext*/ </span><br><span class="line">/* if the probable key size is 5, then the find_each_key_letter function will be execute for 5 time     */ </span><br><span class="line">/* input: seperated cipher text, for example, if peobable size is 5, then, the original ciphertext will   */ </span><br><span class="line">/*        be seperated into 5 parts, for all the letters in each part, their key letter are the same              */ </span><br><span class="line">/* output: the most probable letter, which has the minimum variance                                                 */ </span><br><span class="line"></span><br><span class="line">char find_each_key_letter(char *cipher) </span><br><span class="line">&#123; </span><br><span class="line">  int i; </span><br><span class="line">  double variance[26]; </span><br><span class="line">  double Ke[26]; </span><br><span class="line">  char key; </span><br><span class="line">  double Std_Ke = 0.067; </span><br><span class="line">  double min = 10000; // set a very big value, to find a min </span><br><span class="line">  double min_Ke_off = 1; </span><br><span class="line">  char *plaintext = malloc(strlen(cipher) + 1); </span><br><span class="line">  for(i = 0; i &lt; 26; i++) </span><br><span class="line">  &#123; </span><br><span class="line">    char prob_key[2]; </span><br><span class="line">    prob_key[0] = (char)(i + (int)(&apos;a&apos;)); </span><br><span class="line">    prob_key[1] = &apos;\0&apos;; </span><br><span class="line">    double freq[26]; </span><br><span class="line">    decrypt(cipher, prob_key, plaintext); </span><br><span class="line">    variance[i] = anal_freq(plaintext, freq, &amp;Ke[i]); </span><br><span class="line">    printf(&quot;probable key letter : %s, Ke = %f, variance = %f \n&quot;,prob_key,  Ke[i], variance[i]); </span><br><span class="line">    /*method 1: find the smallest variance*/ </span><br><span class="line">    if(variance[i]&lt; min ) </span><br><span class="line">    &#123; </span><br><span class="line">      key = prob_key[0]; </span><br><span class="line">      min = variance[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    /*method 2: find the closest Ke, this is wrong, because all the Ke are the same*/ </span><br><span class="line">    /*double off = (Ke[i] - Std_Ke) &gt; 0 ? (Ke[i] - Std_Ke) : (Std_Ke - Ke[i]); </span><br><span class="line">    if(off &lt; min_Ke_off) </span><br><span class="line">    &#123; </span><br><span class="line">      key = prob_key[0]; </span><br><span class="line">      min_Ke_off = off; </span><br><span class="line">    &#125;*/ </span><br><span class="line">  &#125; </span><br><span class="line">  free(plaintext); </span><br><span class="line">  return key;  // find the most probable key latter c. </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/690aa174jw1eq93nk7ucyj20kb0cqjzx.jpg" alt="Figure 3.3"></p>
<center><em>Figure 3.3 find most probable key character</em></center>

<p>  From the result in figure 3.3, we can also see that no matter what character was set as key character, Ke, the probability that two randomly chosen letters are the same, is always 0.065136. So we can’t get the most probable key character from Ke.<br>  After “key length” times repetition, we can get the most probable key word, which was shown in figure 3.4.<br><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93o4zxhpj20n703iq4a.jpg" alt="Figure 3.4"></p>
<center><em>Figure 3.4 find the most probable key word</em></center>

<h3 id="Decrypt-the-cipher"><a href="#Decrypt-the-cipher" class="headerlink" title="Decrypt the cipher"></a>Decrypt the cipher</h3><p>  For a given key word, we will get the matched plain text using decrypt function, which was shown below. The result was shown in figure 3.5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*decrpty the viginer ciphertext*/ </span><br><span class="line">void decrypt(char *ciphertext, char *key, char* plaintext) </span><br><span class="line">&#123; </span><br><span class="line">  int    i   ; </span><br><span class="line">  int    j   ; </span><br><span class="line">  int offset ; </span><br><span class="line">  i =    0   ; </span><br><span class="line">  j =    0   ; </span><br><span class="line">  while(ciphertext[i] != &apos;\n&apos; &amp;&amp; ciphertext[i] != &apos;\0&apos;) </span><br><span class="line">  &#123; </span><br><span class="line">    offset = key[j] -(int)(&apos;a&apos;); </span><br><span class="line">    if((ciphertext[i] - (int)&apos;a&apos; - offset) &lt; 0) </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[i] = ciphertext[i] - offset + 26; </span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123; </span><br><span class="line">      plaintext[i] = ciphertext[i] - offset;  //it seems that we can&apos;t modify plaintext </span><br><span class="line">    &#125; </span><br><span class="line">    i++; </span><br><span class="line">    j++; </span><br><span class="line">    if(key[j] == &apos;\n&apos; || key[j] == &apos;\0&apos;) </span><br><span class="line">    &#123; </span><br><span class="line">      j = 0; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  plaintext[i] = &apos;\0&apos;; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/690aa174jw1eq93ojl9fhj210i0alww7.jpg" alt=""></p>
<center><em> Figure 3.5 decryption</em></center>

<p>After decryption, we finally break viginere and get the plaintext.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1]. <a href="http://en.wikipedia.org/wiki/Letter_frequency" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Letter_frequency</a><br>[2]. <a href="http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher</a><br>[3]. <a href="http://sancy.univ-bpclermont.fr/~guitton/enseignements/admin.html" target="_blank" rel="noopener">http://sancy.univ-bpclermont.fr/~guitton/enseignements/admin.html</a></p>
<p>Note:  All the source code was put in <a href="https://github.com/ShelmyLin/network_security" target="_blank" rel="noopener">my github</a></p>

            
          </div>

          

          <footer class="article-footer">
            <a data-url="http://yoursite.com/2014/12/30/break_vigenere/" data-id="cjow1or97000mlsaybsc5e7xd" class="article-share-link">Share</a>
            
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Network-Security/">Network Security</a></li></ul>

          </footer>

        </div>

        
      </article>


      




      


      



    </div>
  </div>
</div>

  </div>

  <footer class="page-footer grey darken-2">
    <div class="footer-copyright">
      <div class="container">
        &copy; 2018 Xiongmin Lin

        <div class="right">
          Powered by <a href="http://hexo.io/" rel="nofollow" class="white-text" target="_blank">Hexo</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="/js/app.js"></script>

</body>
</html>
